@Entity
* 이 클래스를 테이블과 매핑한다고 JPA에게 알려준다.
* 이렇게 @Entity가 사용된 클래스를 엔티티 클래스라 한다.

@Table
* 엔티티 클래스에 매핑할 테이블 정보를 알려준다. 여기서 name 속성을 사용해서 Member엔티티를 MEMBER 테이블에 매핑했다.

@ID
* 엔티티 클래스의 필드를 테이블의 기본 키에 매핑한다.

@Column
* 필드를 컬럼에 매핑한다.

매핑정보가 없는 필드
* age 필드에는 매핑 어노테이션이 없다. 이렇게 매핑 어노테이션을 생략하면 필드명을 사용해서 컬럼명으로 매핑한다.

### persistence.xml 설정
JPA는 persistence.xml을 사용해서 필요한 설정 정보를 관리한다.
이 설정 파일이 META-INF/persistence.xml 클래스 패스 경로에 있으면 별도의 설정 없이 JPA가 인식할 수 있다.

설정파일은 persistence로 시작한다.
JPA설정은 영속성 유닛이라는 것부터 시작하는데 일반적으로 연결할 데이터베이스당 하나의 영속성 유닛을 등록한다.
#### 데이터베이스 방언
SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 JPA에서는 방언(Dialect)이라 한다.
참고로 데이터베이스 방언을 설정하는 방법은 JPA에 표준화되어 있지 않다.
### 애플리케이션 개발
JpaMain.java 코드를 확인해보자.
코드는 크게 3부분으로 나뉘어 있다.
* 엔티티 매니저 설정
* 트랜잭션 관리
* 비즈니스 로직
#### 엔티티 매니저 설정
JPA를 시작하려면 우선 perisitence.xml의 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야 한다.
~~~java
EntityManagerFactory emf =
    Persistence.creataEntityManagerFactory("jpabook");
// 이렇게 하면 이름이 jpabook인 영속성 유닛을 찾아서 엔티티 매니저 팩토리를 생성한다.
// 이때 설정정보를 읽어서 JPA를 위한 기반객체와 
// 구현체에 따라서 커넥션 풀도 생성하므로 비용이 아주 크다. 
~~~
앤티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다.
#### JPQL
jpa를 사용하면 등록,수정,삭제,한건 조회는 SQL를 전혀 사용하지 않았다.
문제는 검색쿼리다. 검색을 하려면 모든 데이터를 애플리케이션에서 불러와서 엔티티 객체로 변경한 다음 검색해야 하는데,
이는 사실상 불가능 하다. 결국 검색 조건이 포함된 SQL을 사용해야 한다.
JPA는 JPQL(Java Persistence Query Language)이라는 쿼리 언어로 이런 문제를 해결한다.
JPQL SQL의 가장 큰 차이점 : JPQL은 데이터베이스 테이블을 전혀 알지 못한다.
JPA는 JPQL을 분석해서 적절한 SQL을 만들어 데이터베이스에서 조회 한다.